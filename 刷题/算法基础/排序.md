<!--
 * @Description:
 * @Author: mytac
 * @Date: 2020-07-15 08:22:18
-->

全文以升序为例

## 1. 快排（mid）

前后两个指针，以第一个元素为基准，后面的指针先走向前移动，一直与基准值比较，直到遇到比基准值小的数，与前面的指针进行交换；交换后前面的指针向后移动，直到遇到比基准值大的数，然后与后面的指针的值交换，之后后面的指针继续走，直到两指针相遇，基准值置于该位置，再以该位置划分为前后两段继续上面的操作。

```js
const quickSort = (arr, low, high) => {
  if (low >= high) return;
  let i = low,
    j = high,
    pivot = arr[low];
  while (i < j) {
    while (i < j && arr[j] > pivot) j--;
    if (i < j) arr[i++] = arr[j];
    while (i < j && arr[i] < pivot) i++;
    if (i < j) arr[j--] = arr[i];
  }
  arr[i] = pivot;
  quickSort(arr, low, i - 1);
  quickSort(arr, i + 1, high);
};
```

## 2. 选择排序(low)

永远是 O(n^2)。从带排序数列中找到最小值放在已排序列的队尾

```js
const ss = (arr) => {
  for (j = 0; j < arr.length; j++) {
    let min = arr[j],
      k = j;
    for (let i = j + 1; i < arr.length; i++) {
      if (arr[i] < min) {
        min = arr[i];
        k = i;
      }
    }
    const temp = arr[j];
    arr[j] = min;
    arr[k] = temp;
  }
};
```

> > > > > > > Stashed changes

## 3. 归并排序

## 4. 冒泡排序

就是两两对比，值大的往后排，O(n^2)

```js
const bubbleSort = (arr) => {
  for (let i = 0; i < arr.length; i++) {
    let j = 0;
    while (j < arr.length - i) {
      if (arr[j] > arr[j + 1]) {
        const temp = arr[j + 1];
        arr[j + 1] = arr[j];
        arr[j] = temp;
      }
      j++;
    }
  }
};
```

## 5. 插入排序

## 6. 希尔排序

## 7. 堆排序

```js
const heapSort = (myArr) => {
  // 构造大顶堆
  const buildHeap = (arr) => {
    for (let i = Math.floor(arr.length / 2) - 1; i >= 0; i -= 1) {
      heapify(arr, i);
    }
  };

  const heapify = (arr, i) => {
    let left = i * 2 + 1,
      right = i * 2 + 2,
      largest = i;
    // 注意下面typeof 这行，如果某节点有零会false。。造成包含0的用例测试不过的原因
    if (typeof arr[left] !== "undefined" && arr[left] > arr[largest]) {
      largest = left;
    }
    if (typeof arr[right] !== "undefined" && arr[right] > arr[largest]) {
      largest = right;
    }

    if (largest !== i) {
      // 改变了
      swap(arr, largest, i);
      heapify(arr, largest);
    }
  };

  const swap = (arr, a, b) => {
    const temp = arr[a];
    arr[a] = arr[b];
    arr[b] = temp;
  };

  const sort = (arr) => {
    const res = [];
    buildHeap(arr);
    while (arr.length) {
      swap(arr, 0, arr.length - 1);
      const item = arr.pop();
      res.push(item);
      heapify(arr, 0);
    }
    return res;
  };

  return sort(myArr);
};
```
